[Controllers\AuthController.cs]
﻿using AutoMapper;
using HelpDeskPro.Dtos.Auth;
using HelpDeskPro.Services.AuthService;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace HelpDeskPro.Controllers
{
    [AllowAnonymous]
    public class AuthController(IMapper _mapper, ILogger<AuthController> _logger, IAuthService _authService) : HelpDeskProBaseController<AuthController>(_logger, _mapper)
    {
        [HttpPost("login")]
        public async Task<ActionResult<AuthResponseDto>> Login([FromBody] LoginRequestDto request)
        {
            var result = await _authService.LoginAsync(request);
            return Ok(result);
        }

        [HttpPost("refresh-token")]
        public async Task<ActionResult<AuthResponseDto>> RefreshToken([FromBody] RefreshTokenRequestDto request)
        {
            var result = await _authService.RefreshTokenAsync(request.RefreshToken);
            return Ok(result);
        }

        [HttpPost("register")]
        public async Task<ActionResult<AuthResponseDto>> Register([FromBody] RegisterUserRequestDto request)
        {
            await _authService.RegisterAsync(request);
            var loginResult = await _authService.LoginAsync(new LoginRequestDto
            {
                Email = request.Email,
                Password = request.Password
            });
            return Ok(loginResult);
        }
    }
}

----------------------------------

[Controllers\HelpDeskProBaseController.cs]
﻿using AutoMapper;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using System.Security.Claims;

namespace HelpDeskPro.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Produces("application/json")]
    [Consumes("application/json")]
    [Authorize]
    public class HelpDeskProBaseController<T>(ILogger<T> logger, IMapper mapper) : ControllerBase
    {
        protected readonly ILogger<T> _logger = logger;
        protected readonly IMapper _mapper = mapper;

        protected string GetClientEmail()
        {
            return User.Claims.FirstOrDefault( c=> c.Type == ClaimTypes.Email)?.Value ?? string.Empty;
        }

        protected string GetClientId()
        {
            return User.Claims.FirstOrDefault( c=> c.Type == ClaimTypes.NameIdentifier)?.Value ?? string.Empty;
        }
        protected string GetClientRole()
        {
            return User.Claims.FirstOrDefault( c=> c.Type == ClaimTypes.Role)?.Value ?? string.Empty;
        }
        protected string GetClientLocale()
        {
            return User.Claims.FirstOrDefault( c=> c.Type == "locale")?.Value ?? string.Empty;
        }
    }
}

----------------------------------

[Controllers\TicketsController.cs]
﻿namespace HelpDeskPro.Controllers
{
    public class TicketsController
    {
    }
}

----------------------------------

[Controllers\UsersController.cs]
﻿using AutoMapper;
using HelpDeskPro.Criterias.Users;
using HelpDeskPro.Dtos.Pagination;
using HelpDeskPro.Dtos.User;
using HelpDeskPro.Services.UserService;
using HelpDeskPro.Utils;
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;

namespace HelpDeskPro.Controllers
{
    [Authorize (Roles = "Admin")]
    public class UsersController(IMapper _mapper, ILogger<UsersController> _logger, IUserService _userService) : HelpDeskProBaseController<UsersController>(_logger, _mapper)
    {
        [HttpPost("get-all")]
        public async Task<ActionResult<GenericPaginationOutputDto<ListUserDto>>> GetUsers([FromBody] GetUsersFiltersInputDto request)
        {
            var result = await _userService.GetUsersAsync(request);

            ResponseHeadersUtils.SetHeader_XPagination(Response, result.PaginationMetadata);

            return Ok(result);
        }

        [HttpGet("{id}")]
        public async Task<ActionResult<DetailUserDto>> GetUserById(int id)
        {
            var userDto = await _userService.GetUserByIdAsync(id);
            return userDto == null ? NotFound() : Ok(userDto);
        }

        [HttpGet("by-email/{email}")]
        public async Task<ActionResult<DetailUserDto>> GetUserByEmail(string email)
        {
            var userDto = await _userService.GetUserByEmailAsync(email);
            return userDto == null ? NotFound() : Ok(userDto);
        }

        [HttpPost("create")]
        public async Task<ActionResult> CreateUser([FromBody] AddUserDto request)
        {
            var userDto = await _userService.CreateUserAsync(request);
            return CreatedAtAction(nameof(GetUserById), new { id = userDto.Id }, userDto);
        }

        [HttpPost("get-grouped-by-role")]
        public async Task<ActionResult<GenericPaginationOutputDto<ListRolesWithUsersDto>>> GetUsersGroupedByRole([FromBody] PaginationInputDto request)
        {
            var result = await _userService.GetUsersGroupedByRoleAsync(request);
            ResponseHeadersUtils.SetHeader_XPagination(Response, result.PaginationMetadata);
            return Ok(result);
        }
    }
}

----------------------------------

[Dtos\ApiErrorResponse.cs]
namespace HelpDeskPro.Dtos
{
    public class ApiErrorResponse
    {
        public string? Descripcion { get; set; }
        public string? Path { get; set; }
        public string? Method { get; set; }
        public string? ExceptionSerialized { get; set; }
        public int? StatusCode { get; set; }
        public string? TraceId { get; set; }
        public string[]? ErrorCodes { get; set; }
    }
}

----------------------------------

[Dtos\FiltersInput.cs]
﻿using HelpDeskPro.Dtos.Pagination;

namespace HelpDeskPro.Dtos
{
    public class FiltersInput : PaginationInputDto
    {
        public bool ExactMatch { get; set; }
    }
}

----------------------------------

[Dtos\Auth\AuthResponseDto.cs]
﻿namespace HelpDeskPro.Dtos.Auth
{
    public class AuthResponseDto
    {
        public string AccessToken { get; set; } = string.Empty;
        public string RefreshToken { get; set; } = string.Empty;
        public DateTime ExpiresAt { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Auth\LoginRequestDto.cs]
﻿namespace HelpDeskPro.Dtos.Auth
{
    public class LoginRequestDto
    {
        public required string Email { get; set; }
        public required string Password { get; set; }
        public string? LanguageCode { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Auth\RefreshTokenRequestDto.cs]
﻿namespace HelpDeskPro.Dtos.Auth
{
    public class RefreshTokenRequestDto
    {
        public string RefreshToken { get; set; } = string.Empty;
    }
}
.
----------------------------------
.
[Dtos\Auth\RegisterUserRequestDto.cs]
﻿namespace HelpDeskPro.Dtos.Auth
{
    public class RegisterUserRequestDto
    {
        public required string Email { get; set; }
        public required string Password { get; set; }
        public required string FirstName { get; set; }
        public required string LastName { get; set; }
        public string? LanguageCode { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Auth\Validators\LoginRequestDtoValidator.cs]
﻿using FluentValidation;
using HelpDeskPro.Consts;

namespace HelpDeskPro.Dtos.Auth.Validators
{
    public class LoginRequestDtoValidator : AbstractValidator<LoginRequestDto>
    {
        public LoginRequestDtoValidator()
        {
            RuleFor(x => x.Email)
                .NotEmpty().WithErrorCode("Email_Required")
                .EmailAddress().WithErrorCode("Email_Invalid");

            RuleFor(x => x.Password)
                .NotEmpty().WithErrorCode("Password_Required")
                .MinimumLength(6).WithErrorCode("Password_MinLength");

            RuleFor(x => x.LanguageCode)
                .Must(BeValidLanguageCode)
                .When(x => !string.IsNullOrWhiteSpace(x.LanguageCode))
                .WithErrorCode("LanguageCode_Invalid");
        }

        private bool BeValidLanguageCode(string? code)
        {
            return code != null && Languages.IsLanguageSupported(code);
        }
    }
}
.
----------------------------------
.
[Dtos\Auth\Validators\RefreshTokenRequestDtoValidator.cs]
﻿using FluentValidation;

namespace HelpDeskPro.Dtos.Auth.Validators
{
    public class RefreshTokenRequestDtoValidator : AbstractValidator<RefreshTokenRequestDto>
    {
        public RefreshTokenRequestDtoValidator()
        {
            RuleFor(x => x.RefreshToken)
                .NotEmpty().WithErrorCode("RefreshToken_Required");
        }
    }
}
.
----------------------------------
.
[Dtos\Auth\Validators\RegisterUserRequestDtoValidator.cs]
﻿using FluentValidation;
using HelpDeskPro.Consts;

namespace HelpDeskPro.Dtos.Auth.Validators
{
    public class RegisterUserRequestDtoValidator : AbstractValidator<RegisterUserRequestDto>
    {
        public RegisterUserRequestDtoValidator()
        {
            RuleFor(x => x.Email)
                .NotEmpty().WithErrorCode("Email_Required")
                .EmailAddress().WithErrorCode("Email_Invalid");

            RuleFor(x => x.Password)
                .NotEmpty().WithErrorCode("Password_Required")
                .MinimumLength(8).WithErrorCode("Password_MinLength");

            RuleFor(x => x.FirstName)
                .NotEmpty().WithErrorCode("FirstName_Required")
                .MaximumLength(100).WithErrorCode("FirstName_MaxLength");

            RuleFor(x => x.LastName)
                .NotEmpty().WithErrorCode("LastName_Required")
                .MaximumLength(100).WithErrorCode("LastName_MaxLength");

            RuleFor(x => x.LanguageCode)
                .Must(BeValidLanguageCode)
                .When(x => !string.IsNullOrWhiteSpace(x.LanguageCode))
                .WithErrorCode("LanguageCode_Invalid");
        }

        private bool BeValidLanguageCode(string? code)
        {
            return code != null && Languages.IsLanguageSupported(code);
        }
    }
}
.
----------------------------------
.
[Dtos\Pagination\GenericPaginationOutputDto.cs]
﻿namespace HelpDeskPro.Dtos.Pagination
{
    public class GenericPaginationOutputDto<TEntity>(List<TEntity> items, PaginationOutputDto paginationMetadata) where TEntity : class
    {
        public List<TEntity> Items { get; set; } = items;
        public PaginationOutputDto PaginationMetadata { get; set; } = paginationMetadata;
    }
}
.
----------------------------------
.
[Dtos\Pagination\PaginationInputDto.cs]
﻿namespace HelpDeskPro.Dtos.Pagination
{
    public class PaginationInputDto
    {
        public int Page { get; set; }
        public int PageSize { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Pagination\PaginationOutputDto.cs]
﻿namespace HelpDeskPro.Dtos.Pagination
{
    public class PaginationOutputDto
    {
        public int TotalItems { get; set; }
        public int TotalPages { get; set; }
        public int CurrentPage { get; set; }
        public int PageSize { get; set; }
        public int PageItems { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Ticket\ListTicketAttachmentDto.cs]
﻿namespace HelpDeskPro.Dtos.Ticket
{
    public class ListTicketAttachmentDto
    {
        public int Id { get; set; }
        public required string FileName { get; set; }
        public required string ContentType { get; set; }
        public long FileSizeBytes { get; set; }
        public DateTime UploadedAt { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Ticket\ListTicketCommentDto.cs]
﻿namespace HelpDeskPro.Dtos.Ticket
{
    public class ListTicketCommentDto
    {
        public int Id { get; set; }
        public required string Body { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Ticket\ListTicketDto.cs]
﻿namespace HelpDeskPro.Dtos.Ticket
{
    public class ListTicketDto
    {
        public int Id { get; set; }
        public required string Title { get; set; }
        public required string Status { get; set; }
        public DateTime CreatedAt { get; set; }
    }
}
.
----------------------------------
.
[Dtos\Ticket\ListTicketsGroupedByStatus.cs]
﻿namespace HelpDeskPro.Dtos.Ticket
{
    public class ListTicketsGroupedByStatus
    {
        public required string Status { get; set; }
        public required List<ListTicketDto> Tickets { get; set; }
    }
}
.
----------------------------------
.
[Dtos\User\AddUserDto.cs]
﻿using HelpDeskPro.Consts;
using HelpDeskPro.Dtos.Auth;

namespace HelpDeskPro.Dtos.User
{
    public class AddUserDto : RegisterUserRequestDto
    {
        public Roles Role { get; set; }
        public bool IsActive { get; set;  } = true;
    }
}
.
----------------------------------
.
[Dtos\User\DetailUserDto.cs]
﻿using HelpDeskPro.Dtos.Ticket;

namespace HelpDeskPro.Dtos.User
{
    public class DetailUserDto : ListUserDto
    {
        public required string FirstName { get; set; }
        public required string LastName { get; set; }
        public required string Role { get; set; }
        public bool IsActive { get; set; }
        public DateTime CreatedAt { get; set; }
        public required string LanguageCode { get; set; }

        // Relaciones

        public List<string> TeamNames { get; set; } = [];
        public ICollection<ListTicketDto> Tickets { get; set; } = [];
        public ICollection<ListTicketDto> AssignedTickets { get; set; } = [];
        public ICollection<ListTicketCommentDto> Comments { get; set; } = [];
        public ICollection<ListTicketAttachmentDto> Attachments { get; set; } = [];
    }
}
.
----------------------------------
.
[Dtos\User\ListRolesWithUsersDto.cs]
﻿namespace HelpDeskPro.Dtos.User
{
    public class ListRolesWithUsersDto
    {
        public string RoleName { get; set; } = string.Empty;
        public List<ListUserDto> Users { get; set; } = [];
    }
}
.
----------------------------------
.
[Dtos\User\ListUserDto.cs]
﻿namespace HelpDeskPro.Dtos.User
{
    public class ListUserDto
    {
        public int Id { get; set; }
        public required string Email { get; set; }
        public DateTime? LastLoginAt { get; set; }
    }
}
.
----------------------------------
.
[Data\HelpDeskProContext.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using System.Reflection;

namespace HelpDeskPro.Data
{
    public class HelpDeskProContext(DbContextOptions<HelpDeskProContext> options) : DbContext(options)
    {
        public DbSet<User> Users => Set<User>();
        public DbSet<Team> Teams => Set<Team>();
        public DbSet<Ticket> Tickets => Set<Ticket>();
        public DbSet<TicketCategory> TicketCategories => Set<TicketCategory>();
        public DbSet<TicketComment> TicketComments => Set<TicketComment>();
        public DbSet<TicketAttachment> TicketAttachments => Set<TicketAttachment>();
        public DbSet<TicketTag> TicketTags => Set<TicketTag>();
        public DbSet<RefreshToken> RefreshTokens => Set<RefreshToken>();

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            // Esta línea aplica TODAS las configuraciones encontradas por assembly
            modelBuilder.ApplyConfigurationsFromAssembly(Assembly.GetExecutingAssembly());
        }
    }
}

----------------------------------

[Data\PagedResult.cs]
﻿namespace HelpDeskPro.Data
{
    public sealed class PagedResult<T>
    {
        public required IReadOnlyList<T> Items { get; init; }
        public required int TotalCount { get; init; }
    }
}

----------------------------------

[Data\UsersByRoleGroup.cs]
﻿using HelpDeskPro.Entities;

namespace HelpDeskPro.Data
{
    public sealed class UsersByRoleGroup
    {
        public required string RoleName { get; init; }
        public required IReadOnlyList<User> Users { get; init; }
    }

}

----------------------------------

[Data\Configurations\RefreshTokenConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class RefreshTokenConfiguration : IEntityTypeConfiguration<RefreshToken>
    {
        public void Configure(EntityTypeBuilder<RefreshToken> builder)
        {
            builder.ToTable("RefreshTokens");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.Token)
                .IsRequired();

            builder.Property(t => t.ExpiresAt)
                .IsRequired();

            builder.Property(t => t.CreatedAt)
                .IsRequired();

            builder.HasIndex(t => t.Token)
                .IsUnique();

            builder.HasOne(t => t.User)
                .WithMany(u => u.RefreshTokens)
                .HasForeignKey(t => t.UserId)
                .OnDelete(DeleteBehavior.Cascade);


        }
    }
}
.
----------------------------------
.
[Data\Configurations\TeamConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TeamConfiguration : IEntityTypeConfiguration<Team>
    {
        public void Configure(EntityTypeBuilder<Team> builder)
        {
            builder.ToTable("Teams");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.Name)
                .IsRequired()
                .HasMaxLength(100);
            builder.HasIndex(t => t.Name)
                .IsUnique();

            builder.Property(t => t.Description)
                .HasMaxLength(500);

            builder.Property(u => u.IsActive)
                .HasDefaultValue(true);

            builder.Property(t => t.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            builder
                .HasMany(t => t.Members)
                .WithMany(u => u.Teams)
                .UsingEntity<Dictionary<string, object>>(
                    "TeamMember",
                    j => j
                        .HasOne<User>()
                        .WithMany()
                        .HasForeignKey("UserId")
                        .HasConstraintName("FK_TeamMember_User")
                        .OnDelete(DeleteBehavior.Cascade),
                    j => j
                        .HasOne<Team>()
                        .WithMany()
                        .HasForeignKey("TeamId")
                        .HasConstraintName("FK_TeamMember_Team")
                        .OnDelete(DeleteBehavior.Cascade),
                    j =>
                    {
                        j.ToTable("TeamMembers");
                        j.HasKey("TeamId", "UserId");
                    });

        }
    }
}
.
----------------------------------
.
[Data\Configurations\TicketAttachmentConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TicketAttachmentConfiguration : IEntityTypeConfiguration<TicketAttachment>
    {
        public void Configure(EntityTypeBuilder<TicketAttachment> builder)
        {
            builder.ToTable("TicketAttachments");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.FileName)
                .IsRequired()
                .HasMaxLength(255);

            builder.Property(t => t.ContentType)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(t => t.FileSizeBytes)
                .IsRequired();

            builder.Property(t => t.StorageUrl)
                .IsRequired()
                .HasMaxLength(500);

            builder.Property(t => t.UploadedAt)
                .IsRequired()
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            // Ticket
            builder.HasOne(a => a.Ticket)
                .WithMany(t => t.TicketAttachments)
                .HasForeignKey(a => a.TicketId)
                .OnDelete(DeleteBehavior.Cascade);

            // UploadedBy
            builder.HasOne(a => a.UploadedBy)
                .WithMany(u => u.UploadedAttachments)
                .HasForeignKey(a => a.UploadedById)
                .OnDelete(DeleteBehavior.Restrict);

        }
    }
}
.
----------------------------------
.
[Data\Configurations\TicketCategoryConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TicketCategoryConfiguration : IEntityTypeConfiguration<TicketCategory>
    {
        public void Configure(EntityTypeBuilder<TicketCategory> builder)
        {
            builder.ToTable("TicketCategories");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.Name)
                .IsRequired()
                .HasMaxLength(100);
            builder.HasIndex(t => t.Name)
                .IsUnique();

            builder.Property(t => t.Description)
                .HasMaxLength(300);

            builder.Property(t => t.IsActive)
                .IsRequired()
                .HasDefaultValue(true);

            builder.Property(t => t.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

        }
    }
}
.
----------------------------------
.
[Data\Configurations\TicketCommentConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TicketCommentConfiguration : IEntityTypeConfiguration<TicketComment>
    {
        public void Configure(EntityTypeBuilder<TicketComment> builder)
        {
            builder.ToTable("TicketComments");

            builder.HasKey(tc => tc.Id);
            builder.Property(tc => tc.Body)
                   .IsRequired()
                   .HasMaxLength(2000);

            builder.Property(tc => tc.IsInternal)
                   .HasDefaultValue(false);

            builder.Property(tc => tc.CreatedAt)
                   .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            // Ticket
            builder.HasOne(c => c.Ticket)
                .WithMany(t => t.TicketComments)
                .HasForeignKey(c => c.TicketId)
                .OnDelete(DeleteBehavior.Cascade);

            // Author
            builder.HasOne(c => c.Author)
                .WithMany(u => u.TicketComments)
                .HasForeignKey(c => c.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);

        }
    }
}
.
----------------------------------
.
[Data\Configurations\TicketConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TicketConfiguration : IEntityTypeConfiguration<Ticket>
    {
        public void Configure(EntityTypeBuilder<Ticket> builder)
        {
            builder.ToTable("Tickets");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.Code)
                .IsRequired()
                .HasMaxLength(20);
            builder.HasIndex(t => t.Code)
                .IsUnique();

            builder.Property(t => t.Title)
                .IsRequired()
                .HasMaxLength(200);

            builder.Property(t => t.Description)
                .IsRequired()
                .HasMaxLength(1000);

            builder.Property(t => t.Status)
                .IsRequired();

            builder.Property(t => t.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            builder.Property(t => t.UpdatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            builder.Property(t => t.IsDeleted)
                .HasDefaultValue(false);

            builder.Property(t => t.Priority).IsRequired();

            // Category (required)
            builder.HasOne(t => t.Category)
                .WithMany(c => c.Tickets)
                .HasForeignKey(t => t.CategoryId)
                .OnDelete(DeleteBehavior.Restrict);

            // Reporter (required)
            builder.HasOne(t => t.Reporter)
                .WithMany(u => u.ReportedTickets)
                .HasForeignKey(t => t.ReporterId)
                .OnDelete(DeleteBehavior.Restrict);

            // Assignee (opcional)
            builder.HasOne(t => t.Assignee)
                .WithMany(u => u.AssignedTickets)
                .HasForeignKey(t => t.AssigneeId)
                .OnDelete(DeleteBehavior.SetNull);

            // Team (opcional)
            builder.HasOne(t => t.Team)
                .WithMany()
                .HasForeignKey(t => t.TeamId)
                .OnDelete(DeleteBehavior.SetNull);

            builder
                .HasMany(t => t.TicketTags)
                .WithMany(tag => tag.Tickets)
                .UsingEntity<Dictionary<string, object>>(
                    "TicketTagAssignment",
                    j => j
                        .HasOne<TicketTag>()
                        .WithMany()
                        .HasForeignKey("TicketTagId")
                        .HasConstraintName("FK_TicketTagAssignment_TicketTag")
                        .OnDelete(DeleteBehavior.Cascade),
                    j => j
                        .HasOne<Ticket>()
                        .WithMany()
                        .HasForeignKey("TicketId")
                        .HasConstraintName("FK_TicketTagAssignment_Ticket")
                        .OnDelete(DeleteBehavior.Cascade),
                    j =>
                    {
                        j.ToTable("TicketTagAssignments");
                        j.HasKey("TicketId", "TicketTagId");
                    });


        }
    }
}
.
----------------------------------
.
[Data\Configurations\TicketTagConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class TicketTagConfiguration : IEntityTypeConfiguration<TicketTag>
    {
        public void Configure(EntityTypeBuilder<TicketTag> builder)
        {
            builder.ToTable("TicketTags");

            builder.HasKey(t => t.Id);

            builder.Property(t => t.Name)
                .IsRequired()
                .HasMaxLength(50);
            builder.HasIndex(t => t.Name)
                .IsUnique();

            builder.Property(t => t.Color)
                .HasMaxLength(7);

            builder.Property(t => t.IsActive)
                .IsRequired()
                .HasDefaultValue(true);

            builder.Property(t => t.CreatedAt)
                .IsRequired()
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();
        }
    }
}
.
----------------------------------
.
[Data\Configurations\UserConfiguration.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.Metadata.Builders;

namespace HelpDeskPro.Data.Configurations
{
    public class UserConfiguration : IEntityTypeConfiguration<User>
    {
        public void Configure(EntityTypeBuilder<User> builder)
        {
            builder.ToTable("Users");

            builder.HasKey(u => u.Id);

            builder.Property(u => u.Email)
                .IsRequired()
                .HasMaxLength(200);

            builder.HasIndex(u => u.Email)
                .IsUnique();

            builder.Property(u => u.PasswordHash)
                .IsRequired();

            builder.Property(u => u.FirstName)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(u => u.LastName)
                .IsRequired()
                .HasMaxLength(100);

            builder.Property(u => u.Role)
                .IsRequired()
                .HasConversion<string>()
                .HasMaxLength(30);

            builder.Property(u => u.IsActive)
                .HasDefaultValue(true);
            builder.Property(u => u.CreatedAt)
                .HasDefaultValueSql("CURRENT_TIMESTAMP").ValueGeneratedOnAdd();

            builder.Property(u => u.LanguageCode)
                .IsRequired()
                .HasMaxLength(5)
                .HasDefaultValue("en");

            // ReportedTickets
            builder.HasMany(u => u.ReportedTickets)
                .WithOne(t => t.Reporter)
                .HasForeignKey(t => t.ReporterId)
                .OnDelete(DeleteBehavior.Restrict);

            // AssignedTickets
            builder.HasMany(u => u.AssignedTickets)
                .WithOne(t => t.Assignee)
                .HasForeignKey(t => t.AssigneeId)
                .OnDelete(DeleteBehavior.SetNull);

            // TicketComments
            builder.HasMany(u => u.TicketComments)
                .WithOne(c => c.Author)
                .HasForeignKey(c => c.AuthorId)
                .OnDelete(DeleteBehavior.Restrict);

            // RefreshTokens (si añades la colección)
            builder.HasMany(u => u.RefreshTokens)
                .WithOne(t => t.User)
                .HasForeignKey(t => t.UserId)
                .OnDelete(DeleteBehavior.Cascade);

        }
    }
}
.
----------------------------------
.
[Data\Repositories\RepositoryBase.cs]
﻿using HelpDeskPro.Criterias;
using Microsoft.EntityFrameworkCore;
using System.Linq.Expressions;

namespace HelpDeskPro.Data.Repositories
{
    public abstract class RepositoryBase<TEntity>(HelpDeskProContext context) where TEntity : class
    {
        protected readonly HelpDeskProContext _context = context;
        protected readonly DbSet<TEntity> _set = context.Set<TEntity>();

        /// <summary>
        /// Aplica todos los criterios sobre un IQueryable.
        /// </summary>
        protected IQueryable<TEntity> ApplyCriteria(
            IQueryable<TEntity> query,
            IEnumerable<CriteriaBase<TEntity>>? criteria)
        {
            if (criteria is null) return query;

            foreach (var c in criteria)
            {
                if (c is null) continue;

                Expression<Func<TEntity, bool>> predicate = c.BuildExpression();
                if (predicate != null)
                {
                    query = query.Where(predicate);
                }
            }

            return query;
        }

        /// <summary>
        /// Aplica paginación y devuelve (items, total).
        /// </summary>
        protected async Task<(List<TEntity> Items, int TotalCount)> ToPagedListAsync(
            IQueryable<TEntity> query,
            int pageNumber,
            int pageSize
        )
        {
            if (pageNumber <= 0) pageNumber = 1;
            if (pageSize <= 0) pageSize = 20;

            int total = await query.CountAsync();

            List<TEntity> items = await query
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .ToListAsync();

            return (items, total);
        }
    }
}
.
----------------------------------
.
[Data\Repositories\RefreshTokenRepository\IRefreshTokenRepository.cs]
﻿namespace HelpDeskPro.Data.Repositories.RefreshTokenRepository
{
    public interface IRefreshTokenRepository
    {
        Task<Entities.RefreshToken?> GetByTokenAsync(string token);
        Task AddAsync(Entities.RefreshToken token);
        Task Revoke(Entities.RefreshToken token);
        Task SaveChangesAsync();
    }
}
.
----------------------------------
.
[Data\Repositories\RefreshTokenRepository\RefreshTokenRepository.cs]
﻿using Microsoft.EntityFrameworkCore;

namespace HelpDeskPro.Data.Repositories.RefreshTokenRepository
{
    public class RefreshTokenRepository(HelpDeskProContext _context) : IRefreshTokenRepository
    {
        public async Task<Entities.RefreshToken?> GetByTokenAsync(string token)
        {
            return await _context.RefreshTokens.FirstOrDefaultAsync(t => t.Token == token);
        }
        public async Task AddAsync(Entities.RefreshToken token)
        {
            await _context.RefreshTokens.AddAsync(token);
        }

        public Task Revoke(Entities.RefreshToken token)
        {
            token.RevokedAt = DateTime.UtcNow;
            _context.RefreshTokens.Update(token);
            return Task.CompletedTask;
        }

        public async Task SaveChangesAsync()
        {
            await _context.SaveChangesAsync();
        }

    }
}
.
----------------------------------
.
[Data\Repositories\UserRepository\IUserRepository.cs]
﻿using HelpDeskPro.Criterias;
using HelpDeskPro.Entities;

namespace HelpDeskPro.Data.Repositories.UserRepository
{
    public interface IUserRepository
    {
        Task<User?> GetByIdAsync(int id);
        Task<User?> GetByEmailAsync(string email);
        Task<User> AddAsync(User user);
        Task<bool> EmailExistsAsync(string email);
        Task SaveChangesAsync();
        Task<PagedResult<User>> GetUsersAsync(
            int pageNumber,
            int pageSize,
            IReadOnlyList<CriteriaBase<User>> criteria
        );
        Task<PagedResult<UsersByRoleGroup>> GetUsersGroupedByRoleAsync(
              int pageNumber,
              int pageSize
        );
    }
}
.
----------------------------------
.
[Data\Repositories\UserRepository\UserRepository.cs]
﻿using HelpDeskPro.Criterias;
using HelpDeskPro.Entities;
using Microsoft.EntityFrameworkCore;

namespace HelpDeskPro.Data.Repositories.UserRepository
{
    public class UserRepository(HelpDeskProContext context) : RepositoryBase<User>(context), IUserRepository
    {
        public async Task<User> AddAsync(User user)
        {
           var entry = await _set.AddAsync(user);
           return entry.Entity;
        }

        public async Task<bool> EmailExistsAsync(string email)
        {
            return await _set.AnyAsync(u => u.Email == email);
        }

        public async Task<User?> GetByEmailAsync(string email)
        {
            return await _set.FirstOrDefaultAsync(u => u.Email == email);
        }

        public async Task<User?> GetByIdAsync(int id)
        {
            return await _set
                .Include(u => u.Teams)
                .Include(u => u.ReportedTickets)
                .Include(u => u.AssignedTickets)
                .Include(u => u.TicketComments)
                .Include(u => u.UploadedAttachments)
                .FirstOrDefaultAsync(u => u.Id == id);
        }

        public async Task SaveChangesAsync()
        {
            await _context.SaveChangesAsync();
        }

        public async Task<PagedResult<User>> GetUsersAsync(
            int pageNumber,
            int pageSize,
            IReadOnlyList<CriteriaBase<User>> criteria
        )
        {
            IQueryable<User> query = _set.AsNoTracking();

            query = ApplyCriteria(query, criteria);

            query = query.OrderByDescending(u => u.CreatedAt);

            var (items, total) = await ToPagedListAsync(
                query,
                pageNumber,
                pageSize
            );

            return new PagedResult<User>
            {
                Items = items,
                TotalCount = total
            };
        }
        public async Task<PagedResult<UsersByRoleGroup>> GetUsersGroupedByRoleAsync(
            int pageNumber,
            int pageSize
        )
        {
            var query = _set
            .AsNoTracking()
            .GroupBy(u => u.Role);

            var totalGroups = await query.CountAsync();

            var groups = await query
                .OrderByDescending(g => g.Key)
                .Skip((pageNumber - 1) * pageSize)
                .Take(pageSize)
                .Select(g => new UsersByRoleGroup
                {
                    RoleName = g.Key.ToString(),
                    Users = g.ToList()
                })
                .ToListAsync();


            return new PagedResult<UsersByRoleGroup>
            {
                Items = groups,
                TotalCount = totalGroups
            };
        }
    }
}
.
----------------------------------
.
[Services\PasswordService.cs]
﻿using HelpDeskPro.Entities;
using Microsoft.AspNetCore.Identity;

namespace HelpDeskPro.Services
{
    public interface IPasswordService
    {
        string HashPassword(string password);
        bool VerifyPassword(string password, string hash);
    }

    public class PasswordService : IPasswordService
    {
        private readonly PasswordHasher<User> _hasher = new();

        public string HashPassword(string password)
        {
            // Puedes pasar null o una instancia de User si lo deseas
            return _hasher.HashPassword(null!, password);
        }

        public bool VerifyPassword(string password, string hash)
        {
            PasswordVerificationResult result = _hasher.VerifyHashedPassword(null!, hash, password);
            return result == PasswordVerificationResult.Success;
        }
    }
}

----------------------------------

[Services\AuthService\AuthService.cs]
﻿using AutoMapper;
using HelpDeskPro.Consts;
using HelpDeskPro.Data.Repositories.RefreshTokenRepository;
using HelpDeskPro.Data.Repositories.UserRepository;
using HelpDeskPro.Dtos.Auth;
using HelpDeskPro.Entities;
using HelpDeskPro.Exceptions;
using Microsoft.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Security.Cryptography;

namespace HelpDeskPro.Services.AuthService
{
    public class AuthService(
        IUserRepository _userRepository,
        IRefreshTokenRepository _refreshTokenRepository,
        ILogger<AuthService> _logger,
        IPasswordService _passwordService,
        IConfiguration _configuration,
        IMapper _mapper
    ) : IAuthService
    {
        public async Task<AuthResponseDto> LoginAsync(LoginRequestDto request)
        {
            var user = await _userRepository.GetByEmailAsync(request.Email);
            if (user == null || !_passwordService.VerifyPassword(request.Password, user.PasswordHash))
            {
                throw new UnauthorizedAccessException("Invalid email or password.");
            }

            var language = request.LanguageCode != null && Languages.IsLanguageSupported(request.LanguageCode)
                ? request.LanguageCode!.ToLowerInvariant()
                : user.LanguageCode;

            // 1) Access token
            var accessToken = GenerateAccessToken(user, language);

            // 2) Refresh token (entity + persistencia)
            var refreshTokenEntity = GenerateRefreshTokenEntity(user.Id);
            await _refreshTokenRepository.AddAsync(refreshTokenEntity);
            await _refreshTokenRepository.SaveChangesAsync();

            return new AuthResponseDto
            {
                AccessToken = accessToken,
                RefreshToken = refreshTokenEntity.Token,
                ExpiresAt = DateTime.UtcNow.AddHours(1)
            };
        }

        public async Task<AuthResponseDto> RefreshTokenAsync(string refreshToken)
        {
            if (string.IsNullOrWhiteSpace(refreshToken))
            {
                throw new UnauthorizedAccessException("Invalid refresh token.");
            }

            var storedToken = await _refreshTokenRepository.GetByTokenAsync(refreshToken) ?? throw new UnauthorizedAccessException("Invalid refresh token.");
            if (storedToken.RevokedAt is not null)
            {
                throw new UnauthorizedAccessException("Refresh token has been revoked.");
            }

            if (storedToken.ExpiresAt <= DateTime.UtcNow)
            {
                throw new UnauthorizedAccessException("Refresh token has expired.");
            }

            // Cargamos el usuario
            var user = storedToken.User
                       ?? await _userRepository.GetByIdAsync(storedToken.UserId)
                       ?? throw new UnauthorizedAccessException("User not found for this token.");

            var language = user.LanguageCode;

            // Rotación de refresh token: revocamos el actual y creamos uno nuevo
            await _refreshTokenRepository.Revoke(storedToken);
            var newRefreshToken = GenerateRefreshTokenEntity(user.Id);
            await _refreshTokenRepository.AddAsync(newRefreshToken);
            await _refreshTokenRepository.SaveChangesAsync();

            var newAccessToken = GenerateAccessToken(user, language);

            return new AuthResponseDto
            {
                AccessToken = newAccessToken,
                RefreshToken = newRefreshToken.Token,
                ExpiresAt = DateTime.UtcNow.AddHours(1)
            };
        }

        public async Task RegisterAsync(RegisterUserRequestDto request)
        {
            var emailExists = await _userRepository.EmailExistsAsync(request.Email);
            if (emailExists)
            {
                throw new ConflictException("Email_Already_Registered");
            }
            var user = _mapper.Map<User>(request);

            user.PasswordHash = _passwordService.HashPassword(request.Password);

            user.LanguageCode = 
                !string.IsNullOrWhiteSpace(request.LanguageCode) && 
                Languages.IsLanguageSupported(request.LanguageCode)
                ? request.LanguageCode!.ToLowerInvariant() 
                : "en";

            await _userRepository.AddAsync(user);
            await _userRepository.SaveChangesAsync();
        }

        // ========================
        // Helpers privados
        // ========================

        private string GenerateAccessToken(User user, string language)
        {
            var secretForKey = _configuration["Authentication:SecretForKey"];
            if (string.IsNullOrWhiteSpace(secretForKey))
            {
                throw new InvalidOperationException("Authentication secret key is not configured.");
            }

            var securityKey = new SymmetricSecurityKey(Convert.FromBase64String(secretForKey));
            var signingCredentials = new SigningCredentials(securityKey, SecurityAlgorithms.HmacSha256);

            var claims = new List<Claim>
            {
                new(ClaimTypes.NameIdentifier, user.Id.ToString()),
                new(ClaimTypes.Email, user.Email),
                new(ClaimTypes.Role, user.Role.ToString()),
                new("locale", language),
            };

            var jwtSecurityToken = new JwtSecurityToken(
                issuer: _configuration["Authentication:Issuer"],
                audience: _configuration["Authentication:Audience"],
                claims: claims,
                notBefore: DateTime.UtcNow,
                expires: DateTime.UtcNow.AddHours(1),
                signingCredentials: signingCredentials
            );

            var tokenHandler = new JwtSecurityTokenHandler();
            return tokenHandler.WriteToken(jwtSecurityToken);
        }

        private static RefreshToken GenerateRefreshTokenEntity(int userId)
        {
            // 32 bytes → 256 bits de entropía
            var randomBytes = RandomNumberGenerator.GetBytes(32);
            var refreshToken = Convert.ToBase64String(randomBytes);

            return new RefreshToken
            {
                UserId = userId,
                Token = refreshToken,
                CreatedAt = DateTime.UtcNow,
                ExpiresAt = DateTime.UtcNow.AddDays(7),
                RevokedAt = null
            };
        }
    }
}
.
----------------------------------
.
[Services\AuthService\IAuthService.cs]
﻿using HelpDeskPro.Dtos.Auth;

namespace HelpDeskPro.Services.AuthService
{
    public interface IAuthService
    {
        Task<AuthResponseDto> LoginAsync(LoginRequestDto request);
        Task<AuthResponseDto> RefreshTokenAsync(string refreshToken);
        Task RegisterAsync(RegisterUserRequestDto request);
    }
}
.
----------------------------------
.
[Services\TicketService\ITicketService.cs]
﻿namespace HelpDeskPro.Services.TicketService
{
    public interface ITicketService
    {
    }
}
.
----------------------------------
.
[Services\TicketService\TicketService.cs]
﻿namespace HelpDeskPro.Services.TicketService
{
    public class TicketService : ITicketService
    {
    }
}
.
----------------------------------
.
[Services\UserService\IUserService.cs]
﻿using HelpDeskPro.Criterias.Users;
using HelpDeskPro.Dtos.Pagination;
using HelpDeskPro.Dtos.User;

namespace HelpDeskPro.Services.UserService
{
    public interface IUserService
    {
        Task<GenericPaginationOutputDto<ListUserDto>> GetUsersAsync(
            GetUsersFiltersInputDto request
            );
        Task<DetailUserDto?> GetUserByIdAsync(int id);
        Task<DetailUserDto?> GetUserByEmailAsync(string email);
        Task<DetailUserDto> CreateUserAsync(AddUserDto request);
        Task<GenericPaginationOutputDto<ListRolesWithUsersDto>> GetUsersGroupedByRoleAsync(PaginationInputDto request);
    }
}
.
----------------------------------
.
[Services\UserService\UserService.cs]
﻿using AutoMapper;
using HelpDeskPro.Criterias;
using HelpDeskPro.Criterias.Users;
using HelpDeskPro.Data.Repositories.UserRepository;
using HelpDeskPro.Dtos.Pagination;
using HelpDeskPro.Dtos.User;
using HelpDeskPro.Entities;

namespace HelpDeskPro.Services.UserService
{
    public class UserService(
        IUserRepository _userRepository,
        ILogger<UserService> _logger,
        IMapper _mapper
    ) : IUserService
    {
        public async Task<GenericPaginationOutputDto<ListUserDto>> GetUsersAsync(GetUsersFiltersInputDto request)
        {
            var critList = new List<CriteriaBase<User>>()
            {
                new GetUsersCriteria(request)
            };
            var (users, total) = await _userRepository.GetUsersAsync(request.Page, request.PageSize, critList);

            var userDtos = _mapper.Map<List<ListUserDto>>(users);

            var paginationMetadata = new PaginationOutputDto
            {
                CurrentPage = request.Page,
                PageSize = request.PageSize,
                PageItems = userDtos.Count,
                TotalItems = total,
                TotalPages = (int)Math.Ceiling((double)total / request.PageSize)
            };
            return new GenericPaginationOutputDto<ListUserDto>(
                userDtos,
                paginationMetadata
            );
        }

        public async Task<DetailUserDto?> GetUserByIdAsync(int id)
        {
            var user = await _userRepository.GetByIdAsync(id);
            if (user == null)
            {
                return null;
            }
            var userDto = _mapper.Map<DetailUserDto>(user);
            return userDto;
        }

        public async Task<DetailUserDto?> GetUserByEmailAsync(string email)
        {
            var user = await _userRepository.GetByEmailAsync(email);
            if (user == null)
            {
                return null;
            }
            var userDto = _mapper.Map<DetailUserDto>(user);
            return userDto;
        }

        public async Task<DetailUserDto> CreateUserAsync(AddUserDto request)
        {
            var user = _mapper.Map<User>(request);
            var createdUser = await _userRepository.AddAsync(user);
            var userDto = _mapper.Map<DetailUserDto>(createdUser);
            return userDto;
        }

        public async Task<GenericPaginationOutputDto<ListRolesWithUsersDto>> GetUsersGroupedByRoleAsync(PaginationInputDto request)
        {
            var (groups, total) = await _userRepository.GetUsersGroupedByRoleAsync(request.Page, request.PageSize);

            var dtoGroups = groups.Select(g => new ListRolesWithUsersDto
            {
                RoleName = g.RoleName,
                Users = _mapper.Map<List<ListUserDto>>(g.Users)
            }).ToList();

            var paginationMetadata = new PaginationOutputDto
            {
                CurrentPage = request.Page,
                PageSize = request.PageSize,
                PageItems = dtoGroups.Count,
                TotalItems = total,
                TotalPages = (int)Math.Ceiling((double)total / request.PageSize)
            };
            return new GenericPaginationOutputDto<ListRolesWithUsersDto>(
                dtoGroups,
                paginationMetadata
            );
        }
    }
}
.
----------------------------------
.
